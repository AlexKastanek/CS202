	For this project, we had to make three different implementations for the queue class. The basis behind a queue is that the first thing that is placed in it, is the first thing to come out. It can be thought of similarly to a line of people or a lineup of songs. Out three different implementations consisted of two array-based queues and one node-based one. The array-based queues differed in how the values inside were manipulated. One of them had the front of the queue stay where it was and incremented rear as items were enqueued. When items were dequeued, what was stored in the front is stored in the parameter that was passed by reference, and all of the items are shifted down so rear may be decremented. The other array-based queue was a wrap implementation. In which, if the queue became full, it would rear would simply wrap around to the beginning and front would be incremented and the item that was originally stored in that position would be overwritten. Whenever an item is dequeued, instead of shifting the entire array down, front is simply incremented and the value that was originally in front is erased and set to 0. The way I made the array wrap was by using modulo division. I pretended that the array had no bounds when incrementing front and rear, but when it came to accessing what front and rear held, I would use the modulo operator to ensure that nothing out of bounds would ever be accessed. This ensured that because the index, the number inside the array bounds I was accessing, never went below 0 and above max-1. For example, let’s say I wanted to enqueue a number 35 times and the max size of the array was only 9. 35 mod 9 is 8, so index would access and change the 8th value in the array, not the nonexistent 35th value. For the node-based implementation, I didn’t have to even worry about bounds. When enqueueing, I incremented rear and linked rear to its last node, and when dequeuing, I incremented front, and the node that was once in front is now NULL. After figuring out the stack implementation, it was much easier wrap my head around queues. I was able to do everything error free, according to my tests, and I didn’t have too many problems getting there. I had a bit of trouble with node-based at first, but once I drew a picture everything was fine. If I had more time, I would make my mainDriver more efficient and make sure everything was working properly. There could still be some errors in there that I just don’t notice.

